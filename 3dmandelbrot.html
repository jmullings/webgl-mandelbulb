<html>

<head>
<title>Learning WebGL &mdash; lesson 3</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif

    /**
 * Mandelbulb.pbk
 * Last update: 14 December 2009
 *
 * Changelog:
 *		1.0		- Initial release
 *		1.0.1	- Fixed a missing asymmetry thanks to Chris King (http://www.dhushara.com)
 *				- Refinements in the colouring
 *      1.0.2   - Added radiolaria option for a funky hair-like effect
 * 				- Incorporated the scalar derivative method as described here:
 *			    - http://www.fractalforums.com/mandelbulb-implementation/realtime-renderingoptimisations/
 *		1.0.3	- Created a quick version of the script as using a boolean flag to determine
 *				  which distance estimation method created long compilation times.
 * 		1.0.4 	- Fixed issue with older graphic cards and the specular highlights
 *
 *
 * Copyright (c) 2009 Tom Beddard
 * http://www.subblue.com
 *
 * For more Flash and PixelBender based generative graphics experiments see:
 * http://www.subblue.com/blog
 *
 * Licensed under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 *
 * Credits and references
 * ======================
 * For the story behind the 3D Mandelbrot see the following page:
 * http://www.skytopia.com/project/fractal/mandelbulb.html
 *
 * The original forum disussion with many implementation details can be found here:
 * http://www.fractalforums.com/3d-fractal-generation/true-3d-mandlebrot-type-fractal/
 *
 * This implementation references the 4D Quaternion GPU Raytracer by Keenan Crane:
 * http://www.devmaster.net/forums/showthread.php?t=4448
 *
 * and the NVIDIA CUDA/OptiX implementation by cbuchner1:
 * http://forums.nvidia.com/index.php?showtopic=150985
 *
 */

/*
uniform int width;
uniform int height;
uniform float pixelSize;
uniform int  antialiasing;
uniform bool  phong;
uniform bool  julia;
uniform bool  radiolaria;
uniform float shadows;
uniform float radiolariaFactor;
uniform float ambientOcclusion;
uniform float ambientOcclusionEmphasis;
uniform float bounding;
uniform float bailout;
uniform float power;
uniform vec2  phase;
uniform vec3  julia_c;
uniform vec3  camera;
uniform vec3  cameraFine;
uniform vec3  cameraRotation;
uniform float cameraZoom;
uniform vec3  light;
uniform vec4  backgroundColor;
uniform vec4  diffuseColor;
uniform vec4  ambientColor;
uniform vec4  lightColor;
uniform float colorSpread;
uniform float rimLight;
uniform float specularity;
uniform float specularExponent;
uniform vec3  rotation;
uniform int   maxIterations;
uniform int   stepLimit;
uniform float epsilonScale;
*/
uniform int time;
uniform vec3 camera;
uniform  mat3 viewRotation;
uniform float power;
uniform int maxIterations; //user defined max iterations, does no good over maxIterationsLimit
const int   maxIterationsLimit = 50;
uniform int antialiasing;
uniform bool julia;

float ftime = float(time); 	
  
const int width = 500;
const int height = 500;
const float pixelSize = 1.0;
//const int  antialiasing = 0;
const bool  phong = true;
// bool  julia = false;
 bool  radiolaria = false;
const float shadows = 0.6496;
const float radiolariaFactor = 0.0;
const float ambientOcclusion = 0.5;
const float ambientOcclusionEmphasis = 0.5;
const float bounding = 1.718;
const float bailout = 4.0;
//float power = 8.0 + cos(ftime / 10000.0) * 4.0;
 vec2  phase = vec2(0.0, 0.0);
 vec3  julia_c = vec3(0.95, 0.0, 0.0);
  // vec3  camera = vec3(1.0, 0.5, 2.0);
 vec3  cameraFine = vec3(0.0, 0.0, 0.0);
  //vec3  cameraRotation = vec3(-10.0, -10.0, 20.0);
 float cameraZoom = 0.0;
 vec3  light = vec3(100, -54.41, 27.94);
 vec4  backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);
 vec4  diffuseColor = vec4(0.7, 0.7, 0.0, 1.0);
 vec4  ambientColor = vec4(0.0, 0.0, 0.9, 1.0);
 vec4  lightColor = vec4(1.0, 1.0, 1.0, 1.0);
 float colorSpread = 0.3146;
 float rimLight = 1.0;
 float specularity = 0.5;
 float specularExponent = 25.0;

vec3 rotation = vec3(0.0, 0.0 , 0.0); 
const int   stepLimit = 125;
const float epsilonScale = 1.0; 



#define PI 3.141592653
#define MIN_EPSILON 3e-7



varying vec3 Position;

vec2 size = vec2(float(width), float(height));
float aspectRatio = size.x / size.y;



/*
// Camera orientation
float c1 = cos(radians(-cameraRotation.x));
float s1 = sin(radians(-cameraRotation.x));
mat3 viewRotationY = mat3( c1, 0, s1,
						0, 1, 0,
					   -s1, 0, c1);

float c2 = cos(radians(-cameraRotation.y));
float s2 = sin(radians(-cameraRotation.y));
mat3 viewRotationZ = mat3( c2, -s2, 0,
					    s2, c2, 0,
						0, 0, 1);

float c3 = cos(radians(-cameraRotation.z));
float s3 = sin(radians(-cameraRotation.z));
mat3 viewRotationX = mat3( 1, 0, 0,
					    0, c3, -s3,
					    0, s3, c3);

mat3 viewRotation = viewRotationX * viewRotationY * viewRotationZ;
*/
// Object rotation
float c4 = cos(radians(-rotation.x));
float s4 = sin(radians(-rotation.x));
mat3 objRotationY = mat3( c4, 0, s4,
					    0, 1, 0,
					  -s4, 0, c4);

float c5 = cos(radians(-rotation.y));
float s5 = sin(radians(-rotation.y));
mat3 objRotationZ = mat3( c5, -s5, 0,
					   s5, c5, 0,
					    0, 0, 1);

float c6 = cos(radians(-rotation.z));
float s6 = sin(radians(-rotation.z));
mat3 objRotationX = mat3( 1, 0, 0,
								   0, c6, -s6,
								   0, s6, c6);

mat3 objRotation = objRotationX * objRotationY * objRotationZ;


//eye = float3(0, 0, camera.w) * viewRotation;
//lightSource = light * viewRotation * 100.0;
vec3 eye = (camera + cameraFine) * objRotation;
//if (eye == float3(0, 0, 0)) eye = float3(0, 0.0001, 0);


// Super sampling
float sampleStep = 1.0 / float(antialiasing + 1);
float sampleContribution = 1.0 / pow(float(antialiasing + 1), 2.0);
float pixel_scale = 1.0 / max(size.x, size.y);

// The fractal calculation
//
// Calculate the closest distance to the fractal boundary and use this
// distance as the size of the step to take in the ray marching.
//
// Fractal formula:
//	  z' = z^p + c
//
// For each iteration we also calculate the derivative so we can estimate
// the distance to the nearest point in the fractal set, which then sets the
// maxiumum step we can move the ray forward before having to repeat the calculation.
//
//	 dz' = p * z^(p-1)
//
// The distance estimation is then calculated with:
//
//   0.5 * |z| * log(|z|) / |dz|
//
float DE(vec3 z0, inout float min_dist)
{
	vec3 c = julia ? julia_c : z0; // Julia set has fixed c, Mandelbrot c changes with location
	vec3 z = z0;
	float pd = power - 1.0;			 // power for derivative

	// Convert z to polar coordinates
	float r	 = length(z);
	float th = atan(z.y, z.x);
	float ph = asin(z.z / r);

	// Record z orbit distance for ambient occulsion shading
	if (r < min_dist) min_dist = r;

	vec3 dz;
	float ph_dz = 0.0;
	float th_dz = 0.0;
	float r_dz	= 1.0;
	float powR, powRsin;

	// Iterate to compute the distance estimator.
	for (int n = 0; n < maxIterationsLimit; n++) {
		if(n >= maxIterations)
		  break;
		// Calculate derivative of
		powR = power * pow(r, pd);
		powRsin = powR * r_dz * sin(ph_dz + pd*ph);
		dz.x = powRsin * cos(th_dz + pd*th) + 1.0;
		dz.y = powRsin * sin(th_dz + pd*th);
		dz.z = powR * r_dz * cos(ph_dz + pd*ph);

		// polar coordinates of derivative dz
		r_dz  = length(dz);
		th_dz = atan(dz.y, dz.x);
		ph_dz = acos(dz.z / r_dz);

		// z iteration
		powR = pow(r, power);
		powRsin = sin(power*ph);
		z.x = powR * powRsin * cos(power*th);
		z.y = powR * powRsin * sin(power*th);
		z.z = powR * cos(power*ph);
		z += c;

		// The triplex power formula applies the azimuthal angle rotation about the y-axis.
		// Constrain this to get some funky effects
		if (radiolaria && z.y > radiolariaFactor) z.y = radiolariaFactor;

		r  = length(z);
		if (r < min_dist) min_dist = r;
		if (r > bailout) break;

		th = atan(z.y, z.x) + phase.x;
		ph = acos(z.z / r) + phase.y;

	}

	// Return the distance estimation value which determines the next raytracing
	// step size, or if whether we are within the threshold of the surface.
	return 0.5 * r * log(r)/r_dz;
}




// Intersect bounding sphere
//
// If we intersect then set the tmin and tmax values to set the start and
// end distances the ray should traverse.
bool intersectBoundingSphere(vec3 origin,
							 vec3 direction,
							 out float tmin,
							 out float tmax)
{
	bool hit = false;
       
       //vec3 pN = vec3(0, 0, 1.0);
       //float  t  = -(dot(origin, pN) + slice) / dot(direction, pN);
       //origin = origin + t * direction;
       
	float b = dot(origin, direction);
	float c = dot(origin, origin) - bounding;
	float disc = b*b - c;			// discriminant
	tmin = tmax = 0.0;

	if (disc > 0.0) {
		// Real root of disc, so intersection
		float sdisc = sqrt(disc);
		float t0 = -b - sdisc;			// closest intersection distance
		float t1 = -b + sdisc;			// furthest intersection distance

		if (t0 >= 0.0) {
			// Ray intersects front of sphere
			float min_dist;
			vec3 z = origin + t0 * direction;
			tmin = DE(z, min_dist);
			tmax = t0 + t1;
		} else if (t0 < 0.0) {
			// Ray starts inside sphere
			float min_dist;
			vec3 z = origin;
			tmin = DE(z, min_dist);
			tmax = t1;
		}
		hit = true;
	}

	return hit;
}


// Calculate the gradient in each dimension from the intersection point
vec3 estimate_normal(vec3 z, float e)
{
	float min_dst;	// Not actually used in this particular case
	vec3 z1 = z + vec3(e, 0, 0);
	vec3 z2 = z - vec3(e, 0, 0);
	vec3 z3 = z + vec3(0, e, 0);
	vec3 z4 = z - vec3(0, e, 0);
	vec3 z5 = z + vec3(0, 0, e);
	vec3 z6 = z - vec3(0, 0, e);

	float dx = DE(z1, min_dst) - DE(z2, min_dst);
	float dy = DE(z3, min_dst) - DE(z4, min_dst);
	float dz = DE(z5, min_dst) - DE(z6, min_dst);

	return normalize(vec3(dx, dy, dz) / (2.0*e));
}


// Computes the direct illumination for point pt with normal N due to
// a point light at light and a viewer at eye.
vec3 Phong(vec3 pt, vec3 N, out float specular)
{
	vec3 diffuse	= vec3(0);			// Diffuse contribution
	vec3 color	= vec3(0);
	specular = 0.0;
	
	vec3 L = normalize(light * objRotation - pt); // find the vector to the light
	float  NdotL = dot(N, L);			// find the cosine of the angle between light and normal

	if (NdotL > 0.0) {
		// Diffuse shading
		diffuse = diffuseColor.rgb + abs(N) * colorSpread;
		diffuse *= lightColor.rgb * NdotL;

		// Phong highlight
		vec3 E = normalize(eye - pt);		// find the vector to the eye
		vec3 R = L - 2.0 * NdotL * N;		// find the reflected vector
		float  RdE = dot(R,E);

		if (RdE <= 0.0) {
			specular = specularity * pow(abs(RdE), specularExponent);
		}
	} else {
		diffuse = diffuseColor.rgb * abs(NdotL) * rimLight;
	}

	return (ambientColor.rgb * ambientColor.a) + diffuse;
}


// Define the ray direction from the pixel coordinates
vec3 rayDirection(vec2 p)
{
	vec3 direction = vec3( 2.0 * aspectRatio * p.x / float(size.x) - aspectRatio,
							  -2.0 * p.y / float(size.y) + 1.0,
							  -2.0 * exp(cameraZoom));
	return normalize(direction * viewRotation * objRotation);
}


// Calculate the output colour for each input pixel
vec4 renderPixel(vec2 pixel)
{
	float tmin, tmax;
	vec3 ray_direction = rayDirection(pixel);
	vec4 pixel_color = backgroundColor;

	if (intersectBoundingSphere(eye, ray_direction, tmin, tmax)) {
		vec3 ray = eye + tmin * ray_direction;

		float dist, ao;
		float min_dist = 4.0;
		float ray_length = tmin;
		float eps = MIN_EPSILON;

		// number of raymarching steps scales inversely with factor
		const int max_steps = int(float(stepLimit) / epsilonScale);
		int i;
		float f;

		for (int i = 0; i < max_steps; ++i) {
			dist = DE(ray, min_dist);

			// March ray forward
			f = epsilonScale * dist;
			ray += f * ray_direction;
			ray_length += f * dist;

			// Are we within the intersection threshold or completely missed the fractal
			if (dist < eps || ray_length > tmax) {
				break;
			}

			// Set the intersection threshold as a function of the ray length away from the camera
			//eps = max(max(MIN_EPSILON, eps_start), pixel_scale * pow(ray_length, epsilonScale));
			eps = max(MIN_EPSILON, pixel_scale * ray_length);
		}


		// Found intersection?
		if (dist < eps) {
			ao	= 1.0 - clamp(1.0 - min_dist * min_dist, 0.0, 1.0) * ambientOcclusion;

			if (phong) {
				vec3 normal = estimate_normal(ray, eps/2.0);
				float specular = 0.0;
				pixel_color.rgb = Phong(ray, normal, specular);

				if (shadows > 0.0) {
					// The shadow ray will start at the intersection point and go
					// towards the point light. We initially move the ray origin
					// a little bit along this direction so that we don't mistakenly
					// find an intersection with the same point again.
					vec3 light_direction = normalize((light - ray) * objRotation);
					ray += normal * eps * 2.0;

					float min_dist2;
					dist = 4.0;

					for (int j = 0; j < max_steps; ++j) {
						dist = DE(ray, min_dist2);

						// March ray forward
						f = epsilonScale * dist;
						ray += f * light_direction;

						// Are we within the intersection threshold or completely missed the fractal
						if (dist < eps || dot(ray, ray) > bounding * bounding) break;
					}

					// Again, if our estimate of the distance to the set is small, we say
					// that there was a hit and so the source point must be in shadow.
					if (dist < eps) {
						pixel_color.rgb *= 1.0 - shadows;
					} else {
						// Only add specular component when there is no shadow
						pixel_color.rgb += specular;
					}
				} else {
					pixel_color.rgb += specular;
				}
			} else {
				// Just use the base colour
				pixel_color.rgb = diffuseColor.rgb;
			}

			ao *= 1.0 - (float(i) / float(max_steps)) * ambientOcclusionEmphasis * 2.0;
			pixel_color.rgb *= ao;
			pixel_color.a = 1.0;
		}
	}

	return pixel_color;
}


// The main loop
void main()
{
	vec4 c = vec4(0, 0, 0, 1.0);
	vec2 p = vec2(Position) * size;
	
	if (antialiasing > 0) {
		// Average detailSuperSample^2 points per pixel
		float i = 0.0;
		float j;
		for (int iindex = 0; iindex<4; iindex++){
			if(i>=1.0){break;}
			i += sampleStep;
			j=0.0;
			for (int jindex = 0; jindex<4; jindex++){
				if(j>=1.0){break;}
				j += sampleStep;
				c += sampleContribution * renderPixel(p + vec2(i, j));
			}
		}
	} else {
		c = renderPixel(p);
	}
	
	if (c.a <= 0.0) discard;
	
	// Return the final color which is still the background color if we didn't hit anything.
	gl_FragColor = c;
}

</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec3 Position;

void main() 
{
	gl_Position = vec4(aVertexPosition, 1.0);//ftransform();
	//gl_FrontColor = gl_Color;
	//gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
	Position = aVertexPosition;//vec3(gl_MultiTexCoord0);
}
</script>


<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

	shaderProgram.time = gl.getUniformLocation(shaderProgram, "time");
      shaderProgram.camera = gl.getUniformLocation(shaderProgram, "camera");
      shaderProgram.viewRotation = gl.getUniformLocation(shaderProgram, "viewRotation");

	shaderProgram.power = gl.getUniformLocation(shaderProgram, "power");
      shaderProgram.maxIterations = gl.getUniformLocation(shaderProgram, "maxIterations");
	shaderProgram.antialiasing = gl.getUniformLocation(shaderProgram, "antialiasing");
	shaderProgram.julia = gl.getUniformLocation(shaderProgram, "julia");
	
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    }


    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }


    var squareVertexPositionBuffer;

    function initBuffers() {
        squareVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        vertices = [
             1.0,  1.0,  0.0,
            -1.0,  1.0,  0.0,
             1.0, -1.0,  0.0,
            -1.0, -1.0,  0.0
            ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 3;
        squareVertexPositionBuffer.numItems = 4;
    }
   
    var currentlyPressedKeys = {};
  var cameraRotation = mat4.create();
  mat4.identity(cameraRotation);
  var cameraPosition = [0.0, 0.0, 2.0];
  
  //mat4.translate(cameraRotation, [1.0, 0.05, 2.0]);
  //mat4.rotate(cameraRotation, 0.0, [0.0, 0.0, 0.0])
    function handleKeyDown(event) {
	  	currentlyPressedKeys[event.keyCode] = true;
  	}
  
	  function handleKeyUp(event) {
		  currentlyPressedKeys[event.keyCode] = false;
	  }

    function handleKeys() {
      var newRotation = mat4.create();
      mat4.identity(newRotation);

//pitch
      if (currentlyPressedKeys[73]) {
        //  i
        mat4.rotate(newRotation, 0.1, [1.0, 0.0, 0.0]);
      }
      if (currentlyPressedKeys[75]) {
        //  k
        mat4.rotate(newRotation, -0.1, [1.0, 0.0, 0.0]);
      }
 //yaw
    if (currentlyPressedKeys[74]) {
          //  j
          mat4.rotate(newRotation, -0.1, [0.0, 1.0, 0.0]);
        }
      if (currentlyPressedKeys[76]) {
        // l
        mat4.rotate(newRotation, 0.1, [0.0, 1.0, 0.0]);
      }
//roll
      if (currentlyPressedKeys[85]) {
        //  u
        mat4.rotate(newRotation, 0.1, [0.0, 0.0, 1.0]);
      }
      if (currentlyPressedKeys[79]) {
        // o
        mat4.rotate(newRotation, -0.1, [0.0, 0.0, 1.0]);
      }

      //set cameraRotation based on new input
      mat4.multiply(newRotation, cameraRotation, cameraRotation);

//use the inverse to compute movement
    var inverseMatrix = mat4.create();
    mat4.inverse(cameraRotation, inverseMatrix);

      //create a vector coming out from the camera to determine which way to move
//for in and out movement
      var zDir = [0.0, 0.0, 1.0];
      mat4.multiplyVec3(inverseMatrix, zDir);
      
      if (currentlyPressedKeys[87]) {
        // w
        cameraPosition[0] -= 0.1 * zDir[0];
        cameraPosition[1] -= 0.1 * zDir[1] ;
        cameraPosition[2] -= 0.1 * zDir[2];
      }
      if (currentlyPressedKeys[83]) {
        // s
        cameraPosition[0] += 0.1 * zDir[0];
        cameraPosition[1] += 0.1 * zDir[1];
        cameraPosition[2] += 0.1 * zDir[2];
      }
      
      //now create a vector pointing to the right as the camera would see it
//for left-right movement
      var xDir = [1.0, 0.0, 0.0];
      mat4.multiplyVec3(inverseMatrix, xDir);
      
      if (currentlyPressedKeys[65]) {
        // a
        cameraPosition[0] -= 0.1 * xDir[0];
        cameraPosition[1] -= 0.1 * xDir[1];
        cameraPosition[2] -= 0.1 * xDir[2];
      }
      
      if (currentlyPressedKeys[68]) {
        // d
        cameraPosition[0] += 0.1 * xDir[0];
        cameraPosition[1] += 0.1 * xDir[1];
        cameraPosition[2] += 0.1 * xDir[2];
      }

//calculate up vector for elevator movement
    var yDir = [0.0, 1.0, 0.0];
      mat4.multiplyVec3(inverseMatrix, yDir);
      
      if (currentlyPressedKeys[69]) {
        // e
        cameraPosition[0] -= 0.1 * yDir[0];
        cameraPosition[1] -= 0.1 * yDir[1];
        cameraPosition[2] -= 0.1 * yDir[2];
      }
      
      if (currentlyPressedKeys[67]) {
        // c
        cameraPosition[0] += 0.1 * yDir[0];
        cameraPosition[1] += 0.1 * yDir[1];
        cameraPosition[2] += 0.1 * yDir[2];
      }
      document.getElementById("cameraDirectionX").value = Math.round(zDir[0] * 100)/100;
      document.getElementById("cameraDirectionY").value = Math.round(zDir[1] * 100)/100;
      document.getElementById("cameraDirectionZ").value = Math.round(zDir[2] * 100)/100;
      
      document.getElementById("cameraPosX").value = Math.round(cameraPosition[0] * 100)/100;
      document.getElementById("cameraPosY").value = Math.round(cameraPosition[1] * 100)/100;
      document.getElementById("cameraPosZ").value = Math.round(cameraPosition[2] * 100)/100;
    }
    var rTri = 0;
    var rSquare = 0;
    var time = 0.0;
//<<<<<<< HEAD
    var power;
    var julia;

//=======
    var lastFPS = 0.0;
    var smoothFPS = 0;
//>>>>>>> f3a57e6bbc0ad2ffe86aaf5e68b0ef95afdb566a
    function drawScene() {
    if(smoothFPS % 10 == 0){
      document.getElementById("fps").value = Math.round(1000000/(time - lastFPS))/100 ;
      lastFPS = time;
    }
    smoothFPS += 1;
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [0.0, 0.0, -3.0]);

        mvPushMatrix();

        mat4.rotate(mvMatrix, degToRad(rSquare), [1, 0, 0]);

        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

      gl.uniform1i(shaderProgram.time, time);
      gl.uniform3fv(shaderProgram.camera, cameraPosition);
      gl.uniformMatrix3fv(shaderProgram.viewRotation, false, mat4.toMat3(cameraRotation));
      setMatrixUniforms();
        
	gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);

        mvPopMatrix();

	gl.uniform1i(shaderProgram.maxIterations, document.getElementById("maxIterations").value);
	
	//changing of powers
	if(document.getElementById("iteratePowers").checked==true){
    	    power = 8.0 + Math.cos(time / 10000.0) * 4.0;
    	    document.getElementById("power").value = power;
	    document.getElementById("power").type = "text";
	}else{
    	    power = document.getElementById("power").value;
	    document.getElementById("power").type = "textarea";
	}
	
	gl.uniform1f(shaderProgram.power, power);

	gl.uniform1i(shaderProgram.antialiasing, document.getElementById("antialiasing").value);

	gl.uniform1f(shaderProgram.julia, document.getElementById("julia").checked);
	
    }


    function animate() {
        time = new Date().getTime();
    }


    function tick() {
        requestAnimFrame(tick);
        handleKeys();
        drawScene();
        animate();
    }


    function webGLStart() {
        var canvas = document.getElementById("lesson03-canvas");
        initGL(canvas);
        initShaders()
        initBuffers();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
      
        tick();
    }

    function showValue(name, newValue)    {
      document.getElementById(name).innerHTML=newValue;
    }
</script>

</head>


<body onload="webGLStart();">
    <a href="http://learningwebgl.com/blog/?p=239">&lt;&lt; Back to Lesson 3</a><br />

    <canvas id="lesson03-canvas" style="border: none;" width="500" height="500"></canvas>
    FPS:<input type="text" id="fps" value="0.0"  />
    <br/>
  Camera Direction: X:<input type="text" id="cameraDirectionX" value="0.0" />
  Y:<input type="text" id="cameraDirectionY" value="0.0" />
  Z:<input type="text" id="cameraDirectionZ" value="-1.0" /> <br/>
  Camera Position: X:<input type="text" id="cameraPosX" value="0.0" />
  Y:<input type="text" id="cameraPosY" value="0.0" />
  Z:<input type="text" id="cameraPosZ" value="2.0" /> <br/>

  Iterate Powers <input type="checkbox" id="iteratePowers" value="iterate" checked/>
  Power: <input type="text" id="power" value="8" /> <br/>

  Max Iterations (provides finer detail):
  <input id="maxIterations" type="range" min="0" max="50" value="10" step="1" 
	 onchange="showValue('iterationValue', this.value)" />
  <span id="iterationValue">10</span> <br/>

  Antialiasing (minimizes distortion):
  <input id="antialiasing" type="range" min="0" max="2" value="0" step="1"
	onchange="showValue('antialiasingValue', this.value)" />

  <span id="antialiasingValue">0</span> <br/>

  Mandelbrot <input id="mandelbrot" type="radio" name="fractalGroup" checked/>
  Julia <input id="julia" type="radio" name="fractalGroup" /><br/>

    <a href="http://learningwebgl.com/blog/?p=239">&lt;&lt; Back to Lesson 3</a><br />
</body>

</html>
