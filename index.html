<html>

<head>
<title>Learning WebGL &mdash; lesson 1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
  precision highp float;
  
  uniform int width;
  uniform int height;
  uniform float pixelSize;
  uniform int  antialiasing;
  uniform bool  phong;
  uniform bool  julia;
  uniform bool  radiolaria;
  uniform float shadows;
  uniform float radiolariaFactor;
  uniform float ambientOcclusion;
  uniform float ambientOcclusionEmphasis;
  uniform float bounding;
  uniform float bailout;
  uniform float power;
  uniform vec2  phase;
  uniform vec3  julia_c;
  uniform vec3  camera;
  uniform vec3  cameraFine;
  uniform vec3  cameraRotation;
  uniform float cameraZoom;
  uniform vec3  light;
  uniform vec4  backgroundColor;
  uniform vec4  diffuseColor;
  uniform vec4  ambientColor;
  uniform vec4  lightColor;
  uniform float colorSpread;
  uniform float rimLight;
  uniform float specularity;
  uniform float specularExponent;
  uniform vec3  rotation;
  uniform int   maxIterations;
  uniform int   stepLimit;
  uniform float epsilonScale;
  
  
  #define PI 3.141592653
  #define MIN_EPSILON 3e-7
  
  uniform sampler2D texture;
  varying vec3 Position;
  
  vec2 size = vec2(float(width), float(height));
  float aspectRatio = size.x / size.y;
  
  // Camera orientation
  float c1 = cos(radians(-cameraRotation.x));
  float s1 = sin(radians(-cameraRotation.x));
  mat3 viewRotationY = mat3( c1, 0, s1,
                            0, 1, 0,
                            -s1, 0, c1);
  
  float c2 = cos(radians(-cameraRotation.y));
  float s2 = sin(radians(-cameraRotation.y));
  mat3 viewRotationZ = mat3( c2, -s2, 0,
                            s2, c2, 0,
                            0, 0, 1);
  
  float c3 = cos(radians(-cameraRotation.z));
  float s3 = sin(radians(-cameraRotation.z));
  mat3 viewRotationX = mat3( 1, 0, 0,
                            0, c3, -s3,
                            0, s3, c3);
  
  mat3 viewRotation = viewRotationX * viewRotationY * viewRotationZ;
  
  // Object rotation
  float c4 = cos(radians(-rotation.x));
  float s4 = sin(radians(-rotation.x));
  mat3 objRotationY = mat3( c4, 0, s4,
                           0, 1, 0,
                           -s4, 0, c4);
  
  float c5 = cos(radians(-rotation.y));
  float s5 = sin(radians(-rotation.y));
  mat3 objRotationZ = mat3( c5, -s5, 0,
                           s5, c5, 0,
                           0, 0, 1);
  
  float c6 = cos(radians(-rotation.z));
  float s6 = sin(radians(-rotation.z));
  mat3 objRotationX = mat3( 1, 0, 0,
                           0, c6, -s6,
                           0, s6, c6);
  
  mat3 objRotation = objRotationX * objRotationY * objRotationZ;
  
  
  //eye = float3(0, 0, camera.w) * viewRotation;
  //lightSource = light * viewRotation * 100.0;
  vec3 eye = (camera + cameraFine) * objRotation;
  //if (eye == float3(0, 0, 0)) eye = float3(0, 0.0001, 0);
  
  
  // Super sampling
  float sampleStep = 1.0 / float(antialiasing + 1);
  float sampleContribution = 1.0 / pow(float(antialiasing + 1), 2.0);
  float pixel_scale = 1.0 / max(size.x, size.y);
  
  // The fractal calculation
  //
  // Calculate the closest distance to the fractal boundary and use this
  // distance as the size of the step to take in the ray marching.
  //
  // Fractal formula:
  //	  z' = z^p + c
  //
  // For each iteration we also calculate the derivative so we can estimate
  // the distance to the nearest point in the fractal set, which then sets the
  // maxiumum step we can move the ray forward before having to repeat the calculation.
  //
  //	 dz' = p * z^(p-1)
  //
  // The distance estimation is then calculated with:
  //
  //   0.5 * |z| * log(|z|) / |dz|
  //
  float DE(vec3 z0, inout float min_dist)
  {
    vec3 c = julia ? julia_c : z0; // Julia set has fixed c, Mandelbrot c changes with location
    vec3 z = z0;
    float pd = power - 1.0;			 // power for derivative
    
    // Convert z to polar coordinates
    float r	 = length(z);
    float th = atan(z.y, z.x);
    float ph = asin(z.z / r);
    
    // Record z orbit distance for ambient occulsion shading
    if (r < min_dist) min_dist = r;
    
    vec3 dz;
    float ph_dz = 0.0;
    float th_dz = 0.0;
    float r_dz	= 1.0;
    float powR, powRsin;
    
    // Iterate to compute the distance estimator.
    int n = 0;
    for (int useless = 0; useless < 100; useless++) {
      if(n > maxIterations)
        break;
      // Calculate derivative of
      powR = power * pow(r, pd);
      powRsin = powR * r_dz * sin(ph_dz + pd*ph);
      dz.x = powRsin * cos(th_dz + pd*th) + 1.0;
      dz.y = powRsin * sin(th_dz + pd*th);
      dz.z = powR * r_dz * cos(ph_dz + pd*ph);
      
      // polar coordinates of derivative dz
      r_dz  = length(dz);
      th_dz = atan(dz.y, dz.x);
      ph_dz = acos(dz.z / r_dz);
      
      // z iteration
      powR = pow(r, power);
      powRsin = sin(power*ph);
      z.x = powR * powRsin * cos(power*th);
      z.y = powR * powRsin * sin(power*th);
      z.z = powR * cos(power*ph);
      z += c;
      
      // The triplex power formula applies the azimuthal angle rotation about the y-axis.
      // Constrain this to get some funky effects
      if (radiolaria && z.y > radiolariaFactor) z.y = radiolariaFactor;
      
      r  = length(z);
      if (r < min_dist) min_dist = r;
      if (r > bailout) break;
      
      th = atan(z.y, z.x) + phase.x;
      ph = acos(z.z / r) + phase.y;
      n++;
    }
    
    // Return the distance estimation value which determines the next raytracing
    // step size, or if whether we are within the threshold of the surface.
    return 0.5 * r * log(r)/r_dz;
  }
  
  
  
  
  // Intersect bounding sphere
  //
  // If we intersect then set the tmin and tmax values to set the start and
  // end distances the ray should traverse.
  bool intersectBoundingSphere(vec3 origin,
                               vec3 direction,
                               out float tmin,
                               out float tmax)
  {
    bool hit = false;
    
    //vec3 pN = vec3(0, 0, 1.0);
    //float  t  = -(dot(origin, pN) + slice) / dot(direction, pN);
    //origin = origin + t * direction;
    
    float b = dot(origin, direction);
    float c = dot(origin, origin) - bounding;
    float disc = b*b - c;			// discriminant
    tmin = tmax = 0.0;
    
    if (disc > 0.0) {
      // Real root of disc, so intersection
      float sdisc = sqrt(disc);
      float t0 = -b - sdisc;			// closest intersection distance
      float t1 = -b + sdisc;			// furthest intersection distance
      
      if (t0 >= 0.0) {
        // Ray intersects front of sphere
        float min_dist;
        vec3 z = origin + t0 * direction;
        tmin = DE(z, min_dist);
        tmax = t0 + t1;
      } else if (t0 < 0.0) {
        // Ray starts inside sphere
        float min_dist;
        vec3 z = origin;
        tmin = DE(z, min_dist);
        tmax = t1;
      }
      hit = true;
    }
    
    return hit;
  }
  
  
  // Calculate the gradient in each dimension from the intersection point
  vec3 estimate_normal(vec3 z, float e)
  {
    float min_dst;	// Not actually used in this particular case
    vec3 z1 = z + vec3(e, 0, 0);
    vec3 z2 = z - vec3(e, 0, 0);
    vec3 z3 = z + vec3(0, e, 0);
    vec3 z4 = z - vec3(0, e, 0);
    vec3 z5 = z + vec3(0, 0, e);
    vec3 z6 = z - vec3(0, 0, e);
    
    float dx = DE(z1, min_dst) - DE(z2, min_dst);
    float dy = DE(z3, min_dst) - DE(z4, min_dst);
    float dz = DE(z5, min_dst) - DE(z6, min_dst);
    
    return normalize(vec3(dx, dy, dz) / (2.0*e));
  }
  
  
  // Computes the direct illumination for point pt with normal N due to
  // a point light at light and a viewer at eye.
  vec3 Phong(vec3 pt, vec3 N, out float specular)
  {
    vec3 diffuse	= vec3(0);			// Diffuse contribution
    vec3 color	= vec3(0);
    specular = 0.0;
    
    vec3 L = normalize(light * objRotation - pt); // find the vector to the light
    float  NdotL = dot(N, L);			// find the cosine of the angle between light and normal
    
    if (NdotL > 0.0) {
      // Diffuse shading
      diffuse = diffuseColor.rgb + abs(N) * colorSpread;
      diffuse *= lightColor.rgb * NdotL;
      
      // Phong highlight
      vec3 E = normalize(eye - pt);		// find the vector to the eye
      vec3 R = L - 2.0 * NdotL * N;		// find the reflected vector
      float  RdE = dot(R,E);
      
      if (RdE <= 0.0) {
        specular = specularity * pow(abs(RdE), specularExponent);
      }
    } else {
      diffuse = diffuseColor.rgb * abs(NdotL) * rimLight;
    }
    
    return (ambientColor.rgb * ambientColor.a) + diffuse;
  }
  
  
  // Define the ray direction from the pixel coordinates
  vec3 rayDirection(vec2 p)
  {
    vec3 direction = vec3( 2.0 * aspectRatio * p.x / float(size.x) - aspectRatio,
                          -2.0 * p.y / float(size.y) + 1.0,
                          -2.0 * exp(cameraZoom));
    return normalize(direction * viewRotation * objRotation);
  }
  
  
  // Calculate the output colour for each input pixel
  vec4 renderPixel(vec2 pixel)
  {
    float tmin, tmax;
    vec3 ray_direction = rayDirection(pixel);
    vec4 pixel_color = backgroundColor;
    
    if (intersectBoundingSphere(eye, ray_direction, tmin, tmax)) {
      vec3 ray = eye + tmin * ray_direction;
      
      float dist, ao;
      float min_dist = 4.0;
      float ray_length = tmin;
      float eps = MIN_EPSILON;
      
      // number of raymarching steps scales inversely with factor
      int max_steps = int(float(stepLimit) / epsilonScale);
      int i;
      float f;
      
      for (i = 0; i < max_steps; ++i) {
        dist = DE(ray, min_dist);
        
        // March ray forward
        f = epsilonScale * dist;
        ray += f * ray_direction;
        ray_length += f * dist;
        
        // Are we within the intersection threshold or completely missed the fractal
        if (dist < eps || ray_length > tmax) {
          break;
        }
        
        // Set the intersection threshold as a function of the ray length away from the camera
        //eps = max(max(MIN_EPSILON, eps_start), pixel_scale * pow(ray_length, epsilonScale));
        eps = max(MIN_EPSILON, pixel_scale * ray_length);
      }
      
      
      // Found intersection?
      if (dist < eps) {
        ao	= 1.0 - clamp(1.0 - min_dist * min_dist, 0.0, 1.0) * ambientOcclusion;
        
        if (phong) {
          vec3 normal = estimate_normal(ray, eps/2.0);
          float specular = 0.0;
          pixel_color.rgb = Phong(ray, normal, specular);
          
          if (shadows > 0.0) {
            // The shadow ray will start at the intersection point and go
            // towards the point light. We initially move the ray origin
            // a little bit along this direction so that we don't mistakenly
            // find an intersection with the same point again.
            vec3 light_direction = normalize((light - ray) * objRotation);
            ray += normal * eps * 2.0;
            
            float min_dist2;
            dist = 4.0;
            
            for (int j = 0; j < max_steps; ++j) {
              dist = DE(ray, min_dist2);
              
              // March ray forward
              f = epsilonScale * dist;
              ray += f * light_direction;
              
              // Are we within the intersection threshold or completely missed the fractal
              if (dist < eps || dot(ray, ray) > bounding * bounding) break;
            }
            
            // Again, if our estimate of the distance to the set is small, we say
            // that there was a hit and so the source point must be in shadow.
            if (dist < eps) {
              pixel_color.rgb *= 1.0 - shadows;
            } else {
              // Only add specular component when there is no shadow
              pixel_color.rgb += specular;
            }
          } else {
            pixel_color.rgb += specular;
          }
        } else {
          // Just use the base colour
          pixel_color.rgb = diffuseColor.rgb;
        }
        
        ao *= 1.0 - (float(i) / float(max_steps)) * ambientOcclusionEmphasis * 2.0;
        pixel_color.rgb *= ao;
        pixel_color.a = 1.0;
      }
    }
    
    return pixel_color;
  }
  
  
  // The main loop
  void main()
  {
    vec4 c = vec4(0, 0, 0, 1.0);
    vec2 p = vec2(Position) * size;
    
    if (antialiasing > 0) {
      // Average detailSuperSample^2 points per pixel
      for (float i = 0.0; i < 1.0; i += sampleStep)
			for (float j = 0.0; j < 1.0; j += sampleStep)
      c += sampleContribution * renderPixel(p + vec2(i, j));
    } else {
      c = renderPixel(p);
    }
    
    if (c.a <= 0.0) discard;
    
    // Return the final color which is still the background color if we didn't hit anything.
    gl_FragColor = c;
  }
  

</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  varying vec3 Position;
  
  void main() 
  {
    gl_Position = aVertexPosition();
    gl_FrontColor = gl_Color;
    gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
    Position = vec3(gl_MultiTexCoord0);
  }
</script>


<script type="text/javascript">

    var gl;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
    }


    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }



    var triangleVertexPositionBuffer;
    var squareVertexPositionBuffer;

    function initBuffers() {
        triangleVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        var vertices = [
             0.0,  1.0,  0.0,
            -1.0, -1.0,  0.0,
             1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        triangleVertexPositionBuffer.itemSize = 3;
        triangleVertexPositionBuffer.numItems = 3;

        squareVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        vertices = [
             1.0,  1.0,  0.0,
            -1.0,  1.0,  0.0,
             1.0, -1.0,  0.0,
            -1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 3;
        squareVertexPositionBuffer.numItems = 4;
    }


    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);


        mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
    }



    function webGLStart() {
        var canvas = document.getElementById("lesson01-canvas");
        initGL(canvas);
        initShaders();
        initBuffers();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        drawScene();
    }


</script>


</head>


<body onload="webGLStart();">
    <a href="http://learningwebgl.com/blog/?p=28">&lt;&lt; Back to Lesson 1</a><br />

    <canvas id="lesson01-canvas" style="border: none;" width="500" height="500"></canvas>

    <br/>
    <a href="http://learningwebgl.com/blog/?p=28">&lt;&lt; Back to Lesson 1</a><br />

    <!-- Google Analytics stuff, please ignore - nothing to do with WebGL :-) -->
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
        try {
            var pageTracker = _gat._getTracker("UA-2240015-5");
            pageTracker._trackPageview();
        } catch(err) {
        }
    </script>

</body>

</html>
